var documenterSearchIndex = {"docs":
[{"location":"getting_started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"getting_started/#Installation","page":"Getting Started","title":"Installation","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"To install CRCBS.jl, start up Julia and type the following code-snipped into the REPL.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> ] # enter package mode by typing \"]\"\n\n(@v1.4) pkg> add https://github.com/kylejbrown17/CRCBS.jl.git","category":"page"},{"location":"getting_started/#Example","page":"Getting Started","title":"Example","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"To construct and solve a predefined multi agent path finding (MAPF) problem:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using CRCBS\nsolver = CBSSolver() # initialize a solver\nprob = init_mapf_1() # initialize the problem\nsolution, cost = solve!(solver,prob) # solve it\noptimal_status(solver) # check if the problem was solved optimally","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"If you want to build your own MAPF problem from scratch:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"# copied from CRCBS/scripts/mapf_demo.jl\nusing CRCBS\n\n## set up the environment\nvtx_grid = initialize_dense_vtx_grid(4,4) # 4 x 4 grid world\n#  1   2   3   4\n#  5   6   7   8\n#  9  10  11  12\n# 13  14  15  16\nenv = construct_factory_env_from_vtx_grid(vtx_grid)\n\n## Define the initial conditions of the robots\nstarts = [1,4]\ngoals = [13,16]\n\ncost_model = FullCostModel(maximum,TravelTime())\n\nprob = init_mapf_problem(env,starts,goals,cost_model)\n\n## define solver\nsolver = CBSSolver() # PIBTPlanner()\n\n# solve the problem\nsolution, cost = solve!(solver,prob)\n# check if the problem was solved to optimality\n@show feasible_status(solver)\n@show optimal_status(solver)","category":"page"},{"location":"library/#Core-Types-and-Methods","page":"Core Types and Methods","title":"Core Types and Methods","text":"","category":"section"},{"location":"library/","page":"Core Types and Methods","title":"Core Types and Methods","text":"PathNode\nPath\nget_s\nget_a\nget_sp\nLowLevelSolution","category":"page"},{"location":"library/#CRCBS.PathNode","page":"Core Types and Methods","title":"CRCBS.PathNode","text":"PathNode{S,A}\n\nIncludes current state s, action a, next state sp\n\n\n\n\n\n","category":"type"},{"location":"library/#CRCBS.Path","page":"Core Types and Methods","title":"CRCBS.Path","text":"Path{S,A,C}\n\nEncodes a motion plan as a sequence of PathNode{S,A}s\n\n\n\n\n\n","category":"type"},{"location":"library/#CRCBS.get_s","page":"Core Types and Methods","title":"CRCBS.get_s","text":"get_s\n\nGet the first state in a PathNode.\n\n\n\n\n\n","category":"function"},{"location":"library/#CRCBS.get_a","page":"Core Types and Methods","title":"CRCBS.get_a","text":"get_a\n\nGet the action in a PathNode.\n\n\n\n\n\n","category":"function"},{"location":"library/#CRCBS.get_sp","page":"Core Types and Methods","title":"CRCBS.get_sp","text":"get_sp\n\nGet the next state in a PathNode.\n\n\n\n\n\n","category":"function"},{"location":"library/#CRCBS.LowLevelSolution","page":"Core Types and Methods","title":"CRCBS.LowLevelSolution","text":"`LowLevelSolution{S,A,T,C}`\n\nContains a list of agent paths and the associated costs.\nParams:\n- `S` is the state type\n- `A` is the action type\n- `T` is the cost type\n- `C` is the cost model type\nElements:\n- `paths::Vector{Path{S,A,T}}` is the vector of paths\n- `costs::Vector{T}` is the vector of costs, one per path\n- `cost::T` is the total cost for the entire solution\n\n\n\n\n\n","category":"type"},{"location":"library/#Core-Interface","page":"Core Types and Methods","title":"Core Interface","text":"","category":"section"},{"location":"library/","page":"Core Types and Methods","title":"Core Types and Methods","text":"is_goal\nget_possible_actions\nget_next_state\nwait\nget_transition_cost\nget_path_cost\nget_heuristic_cost\nbuild_env\nstates_match\nviolates_constraints\ncheck_termination_criteria","category":"page"},{"location":"library/#CRCBS.is_goal","page":"Core Types and Methods","title":"CRCBS.is_goal","text":"`is_goal(env,s)`\n\nReturns true if state `s` satisfies the goal condition of environment `env`\n\n\n\n\n\n","category":"function"},{"location":"library/#CRCBS.get_possible_actions","page":"Core Types and Methods","title":"CRCBS.get_possible_actions","text":"`get_possible_actions(env::E <: AbstractLowLevelEnv{S,A,C}, s::S)`\n\nreturn type must support iteration\n\n\n\n\n\n","category":"function"},{"location":"library/#CRCBS.get_next_state","page":"Core Types and Methods","title":"CRCBS.get_next_state","text":"`get_next_state(env::E <: AbstractLowLevelEnv{S,A,C}, s::S, a::A)`\n\nreturns a next state s\n\n\n\n\n\n","category":"function"},{"location":"library/#CRCBS.get_transition_cost","page":"Core Types and Methods","title":"CRCBS.get_transition_cost","text":"`get_transition_cost(env::E <: AbstractLowLevelEnv{S,A,C},s::S,a::A,sp::S)`\n\nreturn scalar cost for transitioning from `s` to `sp` via `a`\n\n\n\n\n\n","category":"function"},{"location":"library/#CRCBS.get_path_cost","page":"Core Types and Methods","title":"CRCBS.get_path_cost","text":"`get_path_cost(env::E <: AbstractLowLevelEnv{S,A,C},path::Path{S,A,C})`\n\nget the cost associated with a search path so far\n\n\n\n\n\n","category":"function"},{"location":"library/#CRCBS.get_heuristic_cost","page":"Core Types and Methods","title":"CRCBS.get_heuristic_cost","text":"`get_heuristic_cost(env::E <: AbstractLowLevelEnv{S,A,C},state::S)`\n\nget a heuristic \"cost-to-go\" from `state`\n\n\n\n\n\n","category":"function"},{"location":"library/#CRCBS.build_env","page":"Core Types and Methods","title":"CRCBS.build_env","text":"`build_env(mapf::AbstractMAPF, node::ConstraintTreeNode, idx::Int)`\n\nConstructs a new low-level search environment for a conflict-based search\nmapf solver\n\n\n\n\n\n","category":"function"},{"location":"library/#CRCBS.states_match","page":"Core Types and Methods","title":"CRCBS.states_match","text":"`state_match(s1::S,s2::S)`\n\nreturns true if s1 and s2 match (not necessarily the same as equal)\n\n\n\n\n\n","category":"function"},{"location":"library/#CRCBS.violates_constraints","page":"Core Types and Methods","title":"CRCBS.violates_constraints","text":"`violates_constraints(env::E <: AbstractLowLevelEnv{S,A,C},\n    path::Path{S,A,C},s::S,a::A,sp::S)`\n\nreturns `true` if taking action `a` from state `s` violates any constraints\nassociated with `env`\n\n\n\n\n\n","category":"function"},{"location":"library/#CRCBS.check_termination_criteria","page":"Core Types and Methods","title":"CRCBS.check_termination_criteria","text":"`check_termination_criteria(env::E <: AbstractLowLevelEnv{S,A,C}, cost,\n    path::Path{S,A,C}, s::S)`\n\nreturns true if any termination criterion is satisfied\n\n\n\n\n\n","category":"function"},{"location":"library/#Problem-Definitions","page":"Core Types and Methods","title":"Problem Definitions","text":"","category":"section"},{"location":"library/","page":"Core Types and Methods","title":"Core Types and Methods","text":"MAPF","category":"page"},{"location":"library/#CRCBS.MAPF","page":"Core Types and Methods","title":"CRCBS.MAPF","text":"MAPF\n\nA MAPF is a Multi Agent Path Finding problem. It consists of an environment, env, through which a group of agents may navigate, as well as a list of start and goal states in that environment. Note that this is the labeled case, where each agent has a specific assigned destination.\n\nElements:\n\nenv::E - the base environment\nstarts::Vector{S} - the vector of initial states\nstarts::Vector{G} - the vector of goals\n\n\n\n\n\n","category":"type"},{"location":"library/#Cost-Models-and-interface","page":"Core Types and Methods","title":"Cost Models and interface","text":"","category":"section"},{"location":"library/","page":"Core Types and Methods","title":"Core Types and Methods","text":"get_initial_cost\nget_infeasible_cost\nadd_heuristic_cost\naccumulate_cost\naggregate_costs\nCompositCostModel\nMetaCostModel\nTravelTime\nTravelDistance\nCompositeHeuristic\nNullHeuristic\nPerfectHeuristic\nEnvDistanceHeuristic\nMultiStagePerfectHeuristic","category":"page"},{"location":"library/#CRCBS.get_initial_cost","page":"Core Types and Methods","title":"CRCBS.get_initial_cost","text":"get_initial_cost(model)\n\nPart of cost model interface. Defaults to zero.\n\n\n\n\n\n","category":"function"},{"location":"library/#CRCBS.get_infeasible_cost","page":"Core Types and Methods","title":"CRCBS.get_infeasible_cost","text":"get_infeasible_cost(model)\n\nPart of cost model interface. Defaults to zero.\n\n\n\n\n\n","category":"function"},{"location":"library/#CRCBS.add_heuristic_cost","page":"Core Types and Methods","title":"CRCBS.add_heuristic_cost","text":"add_heuristic_cost(cost_model,heuristic_model,cost,h_cost)\n\nDefines the output heuristic cost that results from combining the current path cost cost with a heuristic \"cost-to-go\" h_cost. Gener\n\n\n\n\n\n","category":"function"},{"location":"library/#CRCBS.accumulate_cost","page":"Core Types and Methods","title":"CRCBS.accumulate_cost","text":"accumulate_cost(model,current_cost,transition_cost)\n\nDefines the way that a transition_cost updates the current_cost of a Path.\n\n\n\n\n\n","category":"function"},{"location":"library/#CRCBS.aggregate_costs","page":"Core Types and Methods","title":"CRCBS.aggregate_costs","text":"aggregate_costs(model, costs::Vector{T}) where {T}\n\nDefines how costs from multiple distinct paths are combined into a single cost for the whole solution. For example, the aggregation function for a SumOfTravelTime objective is the sum of individual cost.\n\n\n\n\n\n","category":"function"},{"location":"library/#CRCBS.MetaCostModel","page":"Core Types and Methods","title":"CRCBS.MetaCostModel","text":"MetaCostModel\n\nDefines the cost-updating behavior of MetaCost for MetaAgent applications.\n\n\n\n\n\n","category":"type"},{"location":"library/#CRCBS.TravelTime","page":"Core Types and Methods","title":"CRCBS.TravelTime","text":"TravelTime <: LowLevelCostModel{Float64}\n\nCost model that assigns cost equal to the duration of a path.\n\n\n\n\n\n","category":"type"},{"location":"library/#CRCBS.TravelDistance","page":"Core Types and Methods","title":"CRCBS.TravelDistance","text":"TravelDistance <: LowLevelCostModel{Float64}\n\nCost model that assigns cost equal to the length (distance) of a path.\n\n\n\n\n\n","category":"type"},{"location":"library/#CRCBS.NullHeuristic","page":"Core Types and Methods","title":"CRCBS.NullHeuristic","text":"`NullHeuristic`\n\n\n\n\n\n","category":"type"},{"location":"library/#CRCBS.PerfectHeuristic","page":"Core Types and Methods","title":"CRCBS.PerfectHeuristic","text":"`PerfectHeuristic`\n\nThe Perfect Heuristic stores the exact distance between any vertex in a\ngraph to all goal vertices specified during construction. The distances are\nstored in `dists`, a dictionary which maps a goal vertex `v` to a vector of\ndistances from any other vertex in `1:nv(G)` to `v`.\n\nAn example of how to access the distance from vertex `v1` to goal `v2`:\n`get_heuristic_cost(h,v1,v2) = h.dists[v2][v1]`\n\n\n\n\n\n","category":"type"},{"location":"library/#CRCBS.EnvDistanceHeuristic","page":"Core Types and Methods","title":"CRCBS.EnvDistanceHeuristic","text":"EnvDistanceHeuristic\n\nA convenience struct that allows for the distance matrix to be stored in env instead of the heuristic struct.\n\n\n\n\n\n","category":"type"},{"location":"library/#CRCBS.MultiStagePerfectHeuristic","page":"Core Types and Methods","title":"CRCBS.MultiStagePerfectHeuristic","text":"MultiStagePerfectHeuristic\n\nStores multiple lookup tables corresponding to different stages of a Path- Finding search. Each stage has a different goal. The heuristic value at a particular stage must reflect not just the distance to the next goal but the length of the path through all remaining goals.\n\n\n\n\n\n","category":"type"},{"location":"library/#Solvers","page":"Core Types and Methods","title":"Solvers","text":"","category":"section"},{"location":"library/","page":"Core Types and Methods","title":"Core Types and Methods","text":"AStar\nCBSSolver\nMetaAgentCBS_Solver\nPIBTPlanner\nsolve!\nreset_solver!\nhard_reset_solver!\nSolverLogger\nSolverWrapper","category":"page"},{"location":"library/#CRCBS.AStar","page":"Core Types and Methods","title":"CRCBS.AStar","text":"AStar\n\nA* Path Planner. Fields:\n\nlogger\nreplan : if true, planner will replan with an empty conflict table following   timeout.\n\n\n\n\n\n","category":"type"},{"location":"library/#CRCBS.CBSSolver","page":"Core Types and Methods","title":"CRCBS.CBSSolver","text":"CBSSolver\n\nPath planner that employs Conflict-Based Search.\n\n\n\n\n\n","category":"type"},{"location":"library/#CRCBS.MetaAgentCBS_Solver","page":"Core Types and Methods","title":"CRCBS.MetaAgentCBS_Solver","text":"MetaAgentCBS_Solver\n\nPath planner that employs Meta Agent Conflict-Based Search\n\n\n\n\n\n","category":"type"},{"location":"library/#CRCBS.PIBTPlanner","page":"Core Types and Methods","title":"CRCBS.PIBTPlanner","text":"PIBTPlanner{C}\n\nPlanner based on Priority Inheritance with BackTracking. \n\nPriority Inheritance with Backtracking for Iterative Multi-agent Path Finding Okumura et al, IJCAI 2019 https://www.ijcai.org/Proceedings/2019/0076.pdf\n\n\n\n\n\n","category":"type"},{"location":"library/#CRCBS.solve!","page":"Core Types and Methods","title":"CRCBS.solve!","text":"`solve!(solver, args ...)`\n\nRun the algorithm represented by `solver` on an instance of a Multi-Agent\nPath-Finding problem.\n\n\n\n\n\n","category":"function"},{"location":"library/#CRCBS.reset_solver!","page":"Core Types and Methods","title":"CRCBS.reset_solver!","text":"reset_solver!(solver)\n\nResets iteration counts and start times.\n\n\n\n\n\n","category":"function"},{"location":"library/#CRCBS.hard_reset_solver!","page":"Core Types and Methods","title":"CRCBS.hard_reset_solver!","text":"hard_reset_solver!(solver)\n\nTo be called when no information (other than iteration and time limits) needs to be stored.\n\n\n\n\n\n","category":"function"},{"location":"library/#CRCBS.SolverLogger","page":"Core Types and Methods","title":"CRCBS.SolverLogger","text":"SolverLogger\n\nA logger type for keeping track of thing like runtime, iterations, optimality gap (including upper and lower bound), etc. The following methods allow for  accessing and modifying the SolverLogger's fields, and are extended to solver types that wrap a SolverLogger:\n\niterations(logger)       iterationlimit(logger)  maxiterations(logger)   starttime(logger)       runtimelimit(logger)    deadline(logger)         JuMP.lowerbound(logger) bestcost(logger)        verbosity(logger)        verbosity(val::Int)\t\t debug(logger)            solver_status(logger)\n\nsetiterations!(solver,val) incrementiterationcount!(logger::SolverLogger) setiterationlimit!(solver,val) setmaxiterations!(solver,val) setstarttime!(solver,val) setruntimelimit!(solver,val) setdeadline!(solver,val) setlowerbound!(solver,val) setlowerbound!(logger::SolverLogger{C},val::C) where {C} setlowerbound!(logger::SolverLogger{NTuple{N,T}},val::R) where {N,T<:Real,R<:Real} setlowerbound!(logger::SolverLogger{T},val::R) where {T<:Tuple,R<:Real} setbestcost!(solver,val) setbestcost!(logger::SolverLogger,val) setbestcost!(logger::SolverLogger{NTuple{N,T}},val::R) where {N,T<:Real,R<:Real} setbestcost!(logger::SolverLogger{T},val::R) where {T<:Tuple,R<:Real} setverbosity!(solver,val) setdebug!(solver,val)\n\nThe following methods facilitate control flow based on solver status. checktime(logger) enforcetimelimit!(logger) checkiterations(logger) enforceiterationlimit!(logger)\n\n\n\n\n\n","category":"type"},{"location":"library/#CRCBS.SolverWrapper","page":"Core Types and Methods","title":"CRCBS.SolverWrapper","text":"SolverWrapper\n\nAn abstract type whose concrete instances must have a solver field.\n\n\n\n\n\n","category":"type"},{"location":"library/#Environments","page":"Core Types and Methods","title":"Environments","text":"","category":"section"},{"location":"library/","page":"Core Types and Methods","title":"Core Types and Methods","text":"","category":"page"},{"location":"library/#Profiling","page":"Core Types and Methods","title":"Profiling","text":"","category":"section"},{"location":"library/","page":"Core Types and Methods","title":"Core Types and Methods","text":"FeatureExtractor\nextract_feature\nprofile_solver!\nload_problem\nwrite_results\nrun_profiling\ninit_dataframe\nconstruct_results_dataframe\nconstruct_config_dataframe","category":"page"},{"location":"library/#CRCBS.FeatureExtractor","page":"Core Types and Methods","title":"CRCBS.FeatureExtractor","text":"FeatureExtractor\n\nAbstract type for features that may be reported about the solution to a PC-TAPF     or sequential task assignment problem\n\n\n\n\n\n","category":"type"},{"location":"library/#CRCBS.extract_feature","page":"Core Types and Methods","title":"CRCBS.extract_feature","text":"extract_feature(solution,extractor,solution,solve_time)\n\nFunction must be implemented to extract features from solutions Args:\n\nsolver (pc_tapf solver)\nextractor <: FeatureExtractor\nsolution <: SearchEnv\ntimer_results::NamedTuple{t,bytes,gctime,memallocs}\n\n\n\n\n\n","category":"function"},{"location":"library/#CRCBS.profile_solver!","page":"Core Types and Methods","title":"CRCBS.profile_solver!","text":"profile_solver!(solver,mapf)\n\nProfile solver on mapf: Returns\n\nsolution, timer_results\n\n\n\n\n\n","category":"function"},{"location":"library/#CRCBS.load_problem","page":"Core Types and Methods","title":"CRCBS.load_problem","text":"load_problem(loader,filename)\n\nGeneric function that allows a problem instance to be retrived/constructed from loader (which may cache information) and filename::String (which points to a problem file).\n\n\n\n\n\n","category":"function"},{"location":"library/#CRCBS.write_results","page":"Core Types and Methods","title":"CRCBS.write_results","text":"write_results(loader,solver_config,prob,problem_file,results)\n\nWrite results results of profiling solver_config.solver on problem prob of name problem_name. Can be overloaded to dispatch on problem type when applicable.\n\n\n\n\n\n","category":"function"},{"location":"library/#CRCBS.run_profiling","page":"Core Types and Methods","title":"CRCBS.run_profiling","text":"run_profiling(config,loader)\n\nProfile the performance of one or more solvers on a set of problems defined by files in a directory. Args:\n\nconfig: A named tuple or struct with at least the following fields:\nproblem_dir::String : path to problem files.\nsolver_configs : A vector of objects, each of which has the fields:\nsolver : a solver complying with the CRCBS interface.\nresults_path::String : path at which to store results.\nfeats : A vector of Feature objects, which defines the specific\nfeatures to be extracted and saved.\nLoader: Any kind of cache on which load_problem(loader,problem_file)   can be called.\n\n\n\n\n\n","category":"function"},{"location":"library/#CRCBS.init_dataframe","page":"Core Types and Methods","title":"CRCBS.init_dataframe","text":"init_dataframe(feats::Tuple)\n\nInstantiate an empty dataframe based on the names and types of feature extractors in feats.\n\n\n\n\n\n","category":"function"},{"location":"library/#CRCBS.construct_results_dataframe","page":"Core Types and Methods","title":"CRCBS.construct_results_dataframe","text":"construct_results_dataframe(loader,solver_config,config_template)\n\nCompile results at solver_config.results_path into a DataFrame based on the features stored in solver_config.feats\n\n\n\n\n\n","category":"function"},{"location":"library/#CRCBS.construct_config_dataframe","page":"Core Types and Methods","title":"CRCBS.construct_config_dataframe","text":"construct_results_dataframe(loader,solver_config,config_template)\n\nCompile results at solver_config.results_path into a DataFrame based on the features stored in solver_config.feats\n\n\n\n\n\n","category":"function"},{"location":"reference/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"reference/#Index","page":"API Reference","title":"Index","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"","category":"page"},{"location":"reference/#Docs","page":"API Reference","title":"Docs","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"Modules = [CRCBS,CRCBS.BenchmarkInterface]","category":"page"},{"location":"reference/#CRCBS.AbstractCostModel","page":"API Reference","title":"CRCBS.AbstractCostModel","text":"`AbstractCostModel{T}`\n\n\n\n\n\n","category":"type"},{"location":"reference/#CRCBS.AbstractLowLevelEnv","page":"API Reference","title":"CRCBS.AbstractLowLevelEnv","text":"`AbstractLowLevelEnv{S,A,C}`\n\nDefines a prototype environment for low level search (searching for a path\nfor a single agent).\n\n`S` is the State type, `A` is the action type, and `C` is the cost type. All\nthree must be default constructible (i.e. you can call `S()`, `A()` and `C()`\nwithout throwing errors)\n\nIn general, a concrete subtype of `AbstractLowLevelEnv` may include a graph\nwhose edges are traversed by agents.\n\n\n\n\n\n","category":"type"},{"location":"reference/#CRCBS.CompositeCostModel","page":"API Reference","title":"CRCBS.CompositeCostModel","text":"CompositeCostModel{T}\n\nCombines multiple cost models in a specific order (i.e., to use for cascaded  tie-breaking).\n\n\n\n\n\n","category":"type"},{"location":"reference/#CRCBS.ConflictTable","page":"API Reference","title":"CRCBS.ConflictTable","text":"A lookup table to store all conflicts that have been detected\n\n\n\n\n\n","category":"type"},{"location":"reference/#CRCBS.ConflictTableHeuristic","page":"API Reference","title":"CRCBS.ConflictTableHeuristic","text":"ConflictTableHeuristic{T<:Union{HardConflictTable,SoftConflictTable}} <: LowLevelSearchHeuristic{Float64}\n\nHeuristic model based on conflicts between paths.\n\n\n\n\n\n","category":"type"},{"location":"reference/#CRCBS.ConstraintTreeNode","page":"API Reference","title":"CRCBS.ConstraintTreeNode","text":"A node of a constraint tree. Each node has a set of constraints, a candidate\nsolution (set of robot paths), and a cost\n\n\n\n\n\n","category":"type"},{"location":"reference/#CRCBS.DeadlineCost","page":"API Reference","title":"CRCBS.DeadlineCost","text":"DeadlineCost\n\nIdentical to TravelTime, except for the behavior of add_heuristic_cost.\n\naddheuristiccost: c = max(0.0, t + Î”t - deadline)\n\n\n\n\n\n","category":"type"},{"location":"reference/#CRCBS.DiscreteConstraintTable","page":"API Reference","title":"CRCBS.DiscreteConstraintTable","text":"DiscreteStateTable\n\nStores constraints for a discrete state space\n\n\n\n\n\n","category":"type"},{"location":"reference/#CRCBS.FullCostModel","page":"API Reference","title":"CRCBS.FullCostModel","text":"FullCostModel{F,T,M<:AbstractCostModel{T}} <: AbstractCostModel{T}\n\nThe FullCostModel defines all the behavior required for running CBS-based algorithms.\n\nElements:\n\nf::F must be callable, and defines how a vector of path costs (e.g., the   paths of a solution) should be combined into a single cost that reflects   the cost of the entire path group together\nmodel::M<:AbstractCostModel{T} defines how the cost is computed during low\n\nlevel search (when individual paths are being compared against each other).\n\n\n\n\n\n","category":"type"},{"location":"reference/#CRCBS.GraphEnv","page":"API Reference","title":"CRCBS.GraphEnv","text":"GraphEnv{S,A,C} <: AbstractLowLevelEnv{S,A,C}\n\nAn abstract environment type whose concrete subtypes comply with a standard  interface.\n\n\n\n\n\n","category":"type"},{"location":"reference/#CRCBS.HardConflictTable","page":"API Reference","title":"CRCBS.HardConflictTable","text":"HardConflictTable\n\nStores a lookup table of planned paths for all agents. When agent i queries the table, table.paths[i] (the existing path plan for agent i) must be subtracted so that the agent does not try to avoid conflicts with itself.\n\n\n\n\n\n","category":"type"},{"location":"reference/#CRCBS.LowLevelCostModel","page":"API Reference","title":"CRCBS.LowLevelCostModel","text":"LowLevelCostModel{C}\n\nThe low level cost model defines the objective to be optimized by the solver at the low level. An optimal low level solver will return a path if a feasible path exists) of minimal cost under the objective specified by the associated LowLevelCostModel. The parameter C defines the cost_type of the objective. The following functions must be implemented for a LowLevelCostModel to be used:\n\nget_initial_cost(model::LowLevelCostModel,env) - returns\n\nthe initial_cost for a path\n\nget_transition_cost(model::LowLevelCostModel{C},path::Path,s::S,a::A,   sp::S) where {S,A,C} - defines the cost associated with taking action   a from state s to arrive in state sp according to the objective   defined by model given that s is the \"tip\" of path.\naccumulate_cost(model::LowLevelCostModel{C}, current_cost::C,   transition_cost::C) - defines how cost accumulates as new PathNodes   are added to a Path.\n\n\n\n\n\n","category":"type"},{"location":"reference/#CRCBS.LowLevelSearchHeuristic","page":"API Reference","title":"CRCBS.LowLevelSearchHeuristic","text":"LowLevelSearchHeuristic{C} <: AbstractCostModel{C}\n\nAbstract type of a heuristic that returns cost of type C.\n\n\n\n\n\n","category":"type"},{"location":"reference/#CRCBS.MetaCost","page":"API Reference","title":"CRCBS.MetaCost","text":"MetaCost\n\nMetaCost maintaining separate costs for individual agents that have been combined into a MetaAgent.\n\nindependent_costs::Vector{T} a vector of costs, 1 per agent\ntotal_cost::T the total cost, which reflects the combined cost (its   interpretation depends on the MetaCostModel used to define cost-   upating behavior)\n\n\n\n\n\n","category":"type"},{"location":"reference/#CRCBS.MetaSolution","page":"API Reference","title":"CRCBS.MetaSolution","text":"MetaSolution{S}\n\nWrapper for a LowLevelSolution that allows for keeping track of groups.\n\n\n\n\n\n","category":"type"},{"location":"reference/#CRCBS.MultiDeadlineCost","page":"API Reference","title":"CRCBS.MultiDeadlineCost","text":"MultiDeadlineCost\n\nCombines multiple deadlines according to some specified aggregation function.\n\n\n\n\n\n","category":"type"},{"location":"reference/#CRCBS.NullCost","page":"API Reference","title":"CRCBS.NullCost","text":"NullCost <: LowLevelCostModel{Float64}\n\nCost equal to 0.0.\n\n\n\n\n\n","category":"type"},{"location":"reference/#CRCBS.PIBTCache","page":"API Reference","title":"CRCBS.PIBTCache","text":"PIBTCache{S,A}\n\nContains info to be passed along through recursive calls to the PIBT algorithm for multi-agent path planning. Info to be stored:\n\ncurrent state of each agent (should be lined up at the same time step)\npriority of each agent\nthe planned action (and associated next state) for each agent\nthe search environment for each agent, which contains e.g., the agent's goal,   costmodel, heuristicmodel, etc.\na conflict table of sorts to indicate which states/actions are reserved\ncountdown flags that identify which paths are \"active\". If pibt is operating\n\non a \"ragged\" plan, where some paths have been planned further into the future than others, it needs to ensure that planning does not continue for a given path until all of the other paths have \"caught up\" to it.\n\n\n\n\n\n","category":"type"},{"location":"reference/#CRCBS.PIBTReservationTable","page":"API Reference","title":"CRCBS.PIBTReservationTable","text":"PIBTReservationTable\n\n\n\n\n\n","category":"type"},{"location":"reference/#CRCBS.ReservationTable","page":"API Reference","title":"CRCBS.ReservationTable","text":"ReservationTable\n\nData structure for reserving resources over a time interval. The table stores a vector of reservations for each resource. When a new reservation is added to the table, it is inserted into the reservation vector associated to the requested resource.\n\n\n\n\n\n","category":"type"},{"location":"reference/#CRCBS.ResourceReservation","page":"API Reference","title":"CRCBS.ResourceReservation","text":"ResourceReservation\n\nr::ResourceReservation encodes a that resource r.resource is reserved by agent r.agent_id over time interval r.interval.\n\n\n\n\n\n","category":"type"},{"location":"reference/#CRCBS.SoftConflictTable","page":"API Reference","title":"CRCBS.SoftConflictTable","text":"SoftConflictTable\n\n\n\n\n\n","category":"type"},{"location":"reference/#CRCBS.SoftConflictTable-2","page":"API Reference","title":"CRCBS.SoftConflictTable","text":"construct_empty_lookup_table(graph,T::Int)\n\nReturns a soft lookup table to encode possible paths for each agent through graph. The argument T defines the time horizon of the lookup table.\n\n\n\n\n\n","category":"type"},{"location":"reference/#CRCBS.SolverException","page":"API Reference","title":"CRCBS.SolverException","text":"SolverException\n\nCustom exception type for tracking solver timeouts, etc.\n\n\n\n\n\n","category":"type"},{"location":"reference/#CRCBS.TransformCostModel","page":"API Reference","title":"CRCBS.TransformCostModel","text":"TransformCostModel{T,M<:LowLevelCostModel{T}} <: LowLevelCostModel{T}\n\nApplies a transformation to an underlying cost model.     e.g., TransformCostModel(c->2*c, TravelTime())\n\n\n\n\n\n","category":"type"},{"location":"reference/#CRCBS.a_star!-Union{Tuple{P}, Tuple{E}, Tuple{Any,E,P}, Tuple{Any,E,P,Any}} where P<:CRCBS.AbstractPath where E<:AbstractLowLevelEnv","page":"API Reference","title":"CRCBS.a_star!","text":"a_star!(env,start_state)\n\nA generic implementation of the [A* search algorithm](http://en.wikipedia.org/wiki/A%2A_search_algorithm)\nthat operates on an Environment and initial state.\n\nargs:\n- `env::E <: AbstractLowLevelEnv`\n- `start_state`\n\nThe following methods must be implemented:\n- is_goal(env::E,s::S)\n- check_termination_criteria(env::E,cost::C,path::Path{S,A,C},state::S)\n- get_possible_actions(env::E,s::S)\n- get_next_state(env::E,s::S,a::A,sp::S)\n- get_transition_cost(env::E,s::S,a::A)\n- violates_constraints(env::E,s::S,path::Path{S,A,C})\n\n\n\n\n\n","category":"method"},{"location":"reference/#CRCBS.a_star_impl!-Union{Tuple{E}, Tuple{Any,E,Any,Any,Any}} where E<:AbstractLowLevelEnv","page":"API Reference","title":"CRCBS.a_star_impl!","text":"The internal loop of the A* algorithm.\n\n# g(n) = cost of the path from the start node to n,\n# h(n) = heuristic estimate of cost from n to goal\n# f(n) = g(n) + h(n)\n\n\n\n\n\n","category":"method"},{"location":"reference/#CRCBS.action_space_trait-Tuple{Any}","page":"API Reference","title":"CRCBS.action_space_trait","text":"action_space_trait(env)\n\nDefaults to DiscreteSpace\n\n\n\n\n\n","category":"method"},{"location":"reference/#CRCBS.add_conflict!-Tuple{ConflictTable,Any}","page":"API Reference","title":"CRCBS.add_conflict!","text":"helper to insert conflicts into ConflictTable\n\n\n\n\n\n","category":"method"},{"location":"reference/#CRCBS.add_constraint!","page":"API Reference","title":"CRCBS.add_constraint!","text":"Adds a CBSConstraint to a DiscreteConstraintTable \n\n\n\n\n\n","category":"function"},{"location":"reference/#CRCBS.add_constraint!-Union{Tuple{N}, Tuple{Any,N,CBSConstraint}} where N<:ConstraintTreeNode","page":"API Reference","title":"CRCBS.add_constraint!","text":"adds a `CBSConstraint` to a ConstraintTreeNode\n\n\n\n\n\n","category":"method"},{"location":"reference/#CRCBS.add_fat_path_to_table!","page":"API Reference","title":"CRCBS.add_fat_path_to_table!","text":"add_fat_path_to_table(CAT,fat_path)\n\n\n\n\n\n","category":"function"},{"location":"reference/#CRCBS.add_to_path!-Tuple{Path,Any,Any,Any,Any}","page":"API Reference","title":"CRCBS.add_to_path!","text":"add_to_path!(path,env,s,a,sp)\n\nAdds the new (s,a,sp) tuple and its cost (under env) to path.\n\n\n\n\n\n","category":"method"},{"location":"reference/#CRCBS.aggregate_costs_meta-Tuple{AbstractCostModel,Vararg{Any,N} where N}","page":"API Reference","title":"CRCBS.aggregate_costs_meta","text":"a special version of aggregate_costs for the meta_env\n\n\n\n\n\n","category":"method"},{"location":"reference/#CRCBS.cbs!-Tuple{Any,Any}","page":"API Reference","title":"CRCBS.cbs!","text":"Conflict-Based Search\n\nSharon et al 2012\nhttps://www.aaai.org/ocs/index.php/AAAI/AAAI12/paper/viewFile/5062/5239\n\n\n\n\n\n","category":"method"},{"location":"reference/#CRCBS.cbs_branch!-NTuple{5,Any}","page":"API Reference","title":"CRCBS.cbs_branch!","text":"cbs_branch!(solver,mapf,node,conflict,priority_queue)\n\nPart of CBS interface. Defaults to splitting on the conflict and adding two nodes to the priority_queue, where each of the child nodes has one of the new complementary constraints.\n\n\n\n\n\n","category":"method"},{"location":"reference/#CRCBS.cbs_bypass!-NTuple{4,Any}","page":"API Reference","title":"CRCBS.cbs_bypass!","text":"cbs_bypass!(solver,mapf,node,conflict,priority_queue)\n\nPart of CBS interface. Defaults to false, but can be overridden to modify the priority_queue and/or bypass the branching step of CBS\n\n\n\n\n\n","category":"method"},{"location":"reference/#CRCBS.cbs_update_conflict_table!-NTuple{4,Any}","page":"API Reference","title":"CRCBS.cbs_update_conflict_table!","text":"cbs_update_conflict_table!(solver,mapf,node,constraint)\n\nAllows for flexible conflict-updating dispatch. This function is called within     within the default cbs_branch!() method.\n\n\n\n\n\n","category":"method"},{"location":"reference/#CRCBS.combine_agents!-Tuple{Any,Any}","page":"API Reference","title":"CRCBS.combine_agents!","text":"`combine_agents(conflict_table, groups::Vector{Vector{Int}})`\n\nHelper for merging two (meta) agents into a meta-agent\n\n\n\n\n\n","category":"method"},{"location":"reference/#CRCBS.compute_path_cost-NTuple{4,Any}","page":"API Reference","title":"CRCBS.compute_path_cost","text":"compute_path_cost(model,env,path,i)\n\nCompute the cost of a path from scratch.\n\n\n\n\n\n","category":"method"},{"location":"reference/#CRCBS.construct_config_dataframe-Tuple{Any,Any,Any}","page":"API Reference","title":"CRCBS.construct_config_dataframe","text":"construct_results_dataframe(loader,solver_config,config_template)\n\nCompile results at solver_config.results_path into a DataFrame based on the features stored in solver_config.feats\n\n\n\n\n\n","category":"method"},{"location":"reference/#CRCBS.construct_empty_lookup_table-Tuple{Int64,Int64}","page":"API Reference","title":"CRCBS.construct_empty_lookup_table","text":"construct_empty_lookup_table(G,T::Int)\n\nReturns an empty lookup table.\n\n\n\n\n\n","category":"method"},{"location":"reference/#CRCBS.construct_results_dataframe-Tuple{Any,Any,Any}","page":"API Reference","title":"CRCBS.construct_results_dataframe","text":"construct_results_dataframe(loader,solver_config,config_template)\n\nCompile results at solver_config.results_path into a DataFrame based on the features stored in solver_config.feats\n\n\n\n\n\n","category":"method"},{"location":"reference/#CRCBS.convert_to_vertex_lists-Union{Tuple{Path{S,A,C}}, Tuple{C}, Tuple{A}, Tuple{S}} where C where A<:AbstractGraphAction where S<:AbstractGraphState","page":"API Reference","title":"CRCBS.convert_to_vertex_lists","text":"Helper for displaying Paths \n\n\n\n\n\n","category":"method"},{"location":"reference/#CRCBS.count_conflicts-Tuple{ConflictTable,Int64,Int64}","page":"API Reference","title":"CRCBS.count_conflicts","text":"`count_conflicts(conflict_table::ConflictTable,i::Int,j::Int)`\n\nhelper for counting the number of conflicts between agent i and agent j\n\n\n\n\n\n","category":"method"},{"location":"reference/#CRCBS.create_reservations","page":"API Reference","title":"CRCBS.create_reservations","text":"create_reservation(env,s,a,sp)\n\nMust be overriden for environment env and the relevant state / action types.\n\n\n\n\n\n","category":"function"},{"location":"reference/#CRCBS.create_reservations-2","page":"API Reference","title":"CRCBS.create_reservations","text":"create_reservations(env::GraphEnv,s,a,sp,t=-1)\n\nGenerates three reservations as follows\n\nt0 = get_t(s)\ntF = get_t(sp)\nt_mid = (t0+tF)/2\nreservations = [\n    ResourceReservation{Int}(s_idx,get_agent_id(env),   (t0,    t_mid)),\n    ResourceReservation{Int}(a_idx,get_agent_id(env),   (t0,    tF)),\n    ResourceReservation{Int}(sp_idx,get_agent_id(env),  (t_mid, tF)),\n]\n\nIn this way, the reservations for one path node will not interfere with those for the next path node.\n\n\n\n\n\n","category":"function"},{"location":"reference/#CRCBS.default_solution-Tuple{M} where M<:AbstractMAPF","page":"API Reference","title":"CRCBS.default_solution","text":"`default_solution(solver, mapf::AbstractMAPF)`\n\nDefines what is returned by the solver in case of failure to find a feasible\nsolution.\n\n\n\n\n\n","category":"method"},{"location":"reference/#CRCBS.deserialize","page":"API Reference","title":"CRCBS.deserialize","text":"deserialize(env,idx,t=-1)\n\nDecodes an integer encoding of a state or action of type state_type(env) or action_type(env)\n\n\n\n\n\n","category":"function"},{"location":"reference/#CRCBS.detect_action_conflict-Union{Tuple{P2}, Tuple{P1}, Tuple{P1,P2,Int64}} where P2<:Path where P1<:Path","page":"API Reference","title":"CRCBS.detect_action_conflict","text":"Checks for an ActionConflict between two Paths at time t \n\n\n\n\n\n","category":"method"},{"location":"reference/#CRCBS.detect_action_conflict-Union{Tuple{P2}, Tuple{P1}, Tuple{P1,P2}} where P2<:PathNode where P1<:PathNode","page":"API Reference","title":"CRCBS.detect_action_conflict","text":"Detect an `ActionConflict` between two path nodes. Must be overridden for\neach specific path class\n\n\n\n\n\n","category":"method"},{"location":"reference/#CRCBS.detect_conflicts!-Tuple{ConflictTable,PathNode,PathNode,Int64,Int64,Int64}","page":"API Reference","title":"CRCBS.detect_conflicts!","text":"add detected conflicts to conflict table \n\n\n\n\n\n","category":"method"},{"location":"reference/#CRCBS.detect_conflicts!-Union{Tuple{P2}, Tuple{P1}, Tuple{Any,P1,P2,Int64,Int64,Int64}} where P2<:PathNode where P1<:PathNode","page":"API Reference","title":"CRCBS.detect_conflicts!","text":"add detected conflicts to conflict table \n\n\n\n\n\n","category":"method"},{"location":"reference/#CRCBS.detect_conflicts!-Union{Tuple{P2}, Tuple{P1}, Tuple{Any,P1,P2,Int64,Int64}, Tuple{Any,P1,P2,Int64,Int64,Int64}} where P2<:CRCBS.AbstractPath where P1<:CRCBS.AbstractPath","page":"API Reference","title":"CRCBS.detect_conflicts!","text":"detect conflicts between paths\n\n\n\n\n\n","category":"method"},{"location":"reference/#CRCBS.detect_conflicts!-Union{Tuple{P}, Tuple{Any,Array{P,1}}, Tuple{Any,Array{P,1},Any,Vararg{Any,N} where N}} where P<:CRCBS.AbstractPath","page":"API Reference","title":"CRCBS.detect_conflicts!","text":"Populates a `ConflictTable` with all conflicts that occur in a given vector\nof paths. Conflict checking is performed in a pairwise fashion between\nall paths.\n\nargs:\n- conflict_table        a `ConflictTable` to store the detected conflicts\n- paths:                a list of `Path`s, one for each individual agent\n- idxs                  (optional) a list of agent ids for which to check\n                        collisions against all other agents\n\n\n\n\n\n","category":"method"},{"location":"reference/#CRCBS.detect_state_conflict-Union{Tuple{P2}, Tuple{P1}, Tuple{P1,P2,Int64}} where P2<:CRCBS.AbstractPath where P1<:CRCBS.AbstractPath","page":"API Reference","title":"CRCBS.detect_state_conflict","text":"Checks for a StateConflict between two Paths at time t \n\n\n\n\n\n","category":"method"},{"location":"reference/#CRCBS.detect_state_conflict-Union{Tuple{P2}, Tuple{P1}, Tuple{P1,P2}} where P2<:PathNode where P1<:PathNode","page":"API Reference","title":"CRCBS.detect_state_conflict","text":"Detect a `StateConflict` between two path nodes. Must be overridden for each\nspecific path class\n\n\n\n\n\n","category":"method"},{"location":"reference/#CRCBS.extend_path!-Union{Tuple{P}, Tuple{P,Int64}} where P<:Path","page":"API Reference","title":"CRCBS.extend_path!","text":"extend_path!(path,T)\n\nExtends `path` to match a given length `T` by adding `PathNode`s\ncorresponding to waiting at the final state.\n\nargs:\n- path      the path to be extended\n- the desired length of the new path\n\n\n\n\n\n","category":"method"},{"location":"reference/#CRCBS.extend_path-Union{Tuple{P}, Tuple{P,Vararg{Any,N} where N}} where P<:Path","page":"API Reference","title":"CRCBS.extend_path","text":"extend_path(path,T)\n\nExtends a copy of `path` to match a given length `T` by adding `PathNode`s\ncorresponding to waiting at the final state.\n\nargs:\n- path      the path to be extended\n- the desired length of the new path\n\n\n\n\n\n","category":"method"},{"location":"reference/#CRCBS.generate_constraints_from_conflict-Tuple{Conflict}","page":"API Reference","title":"CRCBS.generate_constraints_from_conflict","text":"generates a Vector of (State or Action) Constraints from a conflict\n\n\n\n\n\n","category":"method"},{"location":"reference/#CRCBS.get_a-Tuple{P} where P<:PathNode","page":"API Reference","title":"CRCBS.get_a","text":"get_a\n\nGet the action in a PathNode.\n\n\n\n\n\n","category":"method"},{"location":"reference/#CRCBS.get_agent_idxs-NTuple{4,Any}","page":"API Reference","title":"CRCBS.get_agent_idxs","text":"get_agent_idxs(solver,node,mapf,constraint)\n\nPart of CBS interface. Defaults to return the index of a single agent affected by a constraint. Can be overridden to return the index of e.g., a \"meta-agent\" (group of agents).\n\n\n\n\n\n","category":"method"},{"location":"reference/#CRCBS.get_conflict_index-Tuple{PIBTCache,Any,Any,Any,Any}","page":"API Reference","title":"CRCBS.get_conflict_index","text":"get_conflict_index(cache,i,s,a,sp)\n\nReturns the index of an agent that currently occupies sp, or -1 if there is no such agent.\n\n\n\n\n\n","category":"method"},{"location":"reference/#CRCBS.get_conflicting_paths-Tuple{T} where T<:HardConflictTable","page":"API Reference","title":"CRCBS.get_conflicting_paths","text":"get_conflicting_paths\n\nOperates over a lookup table and returns a dictionary mapping path index to the  time index at which the conflict occurred\n\n\n\n\n\n","category":"method"},{"location":"reference/#CRCBS.get_conflicts-Tuple{ConflictTable,Int64,Int64}","page":"API Reference","title":"CRCBS.get_conflicts","text":"helper for retrieving conflicts associated with agents i and j \n\n\n\n\n\n","category":"method"},{"location":"reference/#CRCBS.get_constraints-Union{Tuple{N}, Tuple{N,Int64}} where N<:ConstraintTreeNode","page":"API Reference","title":"CRCBS.get_constraints","text":"retrieve constraints corresponding to this node and this path\n\n\n\n\n\n","category":"method"},{"location":"reference/#CRCBS.get_cost_model-Union{Tuple{E}, Tuple{C}, Tuple{A}, Tuple{S}} where E<:AbstractLowLevelEnv{S,A,C} where C where A where S","page":"API Reference","title":"CRCBS.get_cost_model","text":"Override this method for when the cost model has arguments \n\n\n\n\n\n","category":"method"},{"location":"reference/#CRCBS.get_fat_path-Tuple{Any,Any,Int64,Int64}","page":"API Reference","title":"CRCBS.get_fat_path","text":"get_fat_path(G,D,start_vtx,goal_vtx)\n\nreturns a fat path through G from start_vtx to goal_vtx. Each set of vertices in the fat path contains all vertices with distance d1 from startvtx and distance d2 to goalvtx, where d1+d2 == the length of the shortest path(s) from start_vtx to goal_vtx\n\nG is a graph, D is the distance matrix\n\n\n\n\n\n","category":"method"},{"location":"reference/#CRCBS.get_fat_path_cost-Tuple{FlatFPCost,Any}","page":"API Reference","title":"CRCBS.get_fat_path_cost","text":"get_fat_path_cost(model,nodes)\n\nReturns a scalar cost value depending on typeof(model) and length(nodes).\n\nget_fat_path_cost(m::FlatFPCost,nodes) = 1.0\nget_fat_path_cost(m::NormalizedFPCost,nodes) = 1.0/length(nodes)\n\n\n\n\n\n","category":"method"},{"location":"reference/#CRCBS.get_infeasible_cost-Tuple{Any}","page":"API Reference","title":"CRCBS.get_infeasible_cost","text":"get_infeasible_cost(model)\n\nPart of cost model interface. Defaults to zero.\n\n\n\n\n\n","category":"method"},{"location":"reference/#CRCBS.get_infeasible_solution-Union{Tuple{MAPF{E,S,G}}, Tuple{E}, Tuple{C}, Tuple{T}, Tuple{G}, Tuple{A}, Tuple{S}} where E<:AbstractLowLevelEnv{S,A,C} where C<:AbstractCostModel{T} where T where G where A where S","page":"API Reference","title":"CRCBS.get_infeasible_solution","text":"`get_infeasible_solution`\n\n\n\n\n\n","category":"method"},{"location":"reference/#CRCBS.get_initial_cost-Tuple{Any}","page":"API Reference","title":"CRCBS.get_initial_cost","text":"get_initial_cost(model)\n\nPart of cost model interface. Defaults to zero.\n\n\n\n\n\n","category":"method"},{"location":"reference/#CRCBS.get_initial_solution-Union{Tuple{MAPF{E,S,G}}, Tuple{E}, Tuple{C}, Tuple{T}, Tuple{G}, Tuple{A}, Tuple{S}} where E<:AbstractLowLevelEnv{S,A,C} where C<:AbstractCostModel{T} where T where G where A where S","page":"API Reference","title":"CRCBS.get_initial_solution","text":"`get_initial_solution`\n\n\n\n\n\n","category":"method"},{"location":"reference/#CRCBS.get_level_set_nodes","page":"API Reference","title":"CRCBS.get_level_set_nodes","text":"get_level_set_nodes(env,s,threshold,cost=get_initial_cost(env))\n\nReturns a vector of PathNodes, where the heuristic cost (according to env) of each node falls below threshold.\n\n\n\n\n\n","category":"function"},{"location":"reference/#CRCBS.get_next_conflict-Tuple{ConflictTable}","page":"API Reference","title":"CRCBS.get_next_conflict","text":"`get_next_conflict(conflict_table::ConflictTable)`\n\nReturns the next conflict (temporally) that occurs in a conflict table\n\n\n\n\n\n","category":"method"},{"location":"reference/#CRCBS.get_path_node-Union{Tuple{P}, Tuple{P,Int64}} where P<:CRCBS.AbstractPath","page":"API Reference","title":"CRCBS.get_path_node","text":"returns the `PathNode` (s,a,s') corresponding to step `t` of `path`\n\nIf `t` is greater than the length of `path`, the `PathNode` returned\nis (s,wait(s),s) corresponding to waiting at that node of the path.\n\npath[t] is the path node that begins at t-1 and terminates at t\n\n\n\n\n\n","category":"method"},{"location":"reference/#CRCBS.get_s-Tuple{P} where P<:PathNode","page":"API Reference","title":"CRCBS.get_s","text":"get_s\n\nGet the first state in a PathNode.\n\n\n\n\n\n","category":"method"},{"location":"reference/#CRCBS.get_sp-Tuple{P} where P<:PathNode","page":"API Reference","title":"CRCBS.get_sp","text":"get_sp\n\nGet the next state in a PathNode.\n\n\n\n\n\n","category":"method"},{"location":"reference/#CRCBS.handle_solver_exception-Tuple{Any,Any}","page":"API Reference","title":"CRCBS.handle_solver_exception","text":"handle_solver_exception\n\nTakes care of printing SolverExceptions\n\n\n\n\n\n","category":"method"},{"location":"reference/#CRCBS.hard_reset_solver!-Tuple{SolverLogger}","page":"API Reference","title":"CRCBS.hard_reset_solver!","text":"hard_reset_solver!(solver)\n\nTo be called when no information (other than iteration and time limits) needs to be stored.\n\n\n\n\n\n","category":"method"},{"location":"reference/#CRCBS.has_constraint-Tuple{Any,DiscreteConstraintTable,CBSConstraint}","page":"API Reference","title":"CRCBS.has_constraint","text":"has_constraint(env,table,c::CBSConstraint)\n\n\n\n\n\n","category":"method"},{"location":"reference/#CRCBS.init_dataframe","page":"API Reference","title":"CRCBS.init_dataframe","text":"init_dataframe(feats::Tuple)\n\nInstantiate an empty dataframe based on the names and types of feature extractors in feats.\n\n\n\n\n\n","category":"function"},{"location":"reference/#CRCBS.init_mapf_2-Tuple","page":"API Reference","title":"CRCBS.init_mapf_2","text":"switch places\n\n\n\n\n\n","category":"method"},{"location":"reference/#CRCBS.init_mapf_3-Tuple","page":"API Reference","title":"CRCBS.init_mapf_3","text":"congested\n\n\n\n\n\n","category":"method"},{"location":"reference/#CRCBS.init_mapf_4-Tuple","page":"API Reference","title":"CRCBS.init_mapf_4","text":"almost switch corners. With the fat path heuristic, the paths should be:\n- Robot 1: [1,5,9,13,14,15]\n- Robot 2: [16,12,8,4,3,2]\n\n\n\n\n\n","category":"method"},{"location":"reference/#CRCBS.init_mapf_5-Tuple","page":"API Reference","title":"CRCBS.init_mapf_5","text":"PIBT demo from paper\n\n\n\n\n\n","category":"method"},{"location":"reference/#CRCBS.initialize_child_search_node-Union{Tuple{N}, Tuple{N,Any}} where N<:ConstraintTreeNode","page":"API Reference","title":"CRCBS.initialize_child_search_node","text":"`initialize_child_search_node(parent_node::ConstraintTreeNode)`\n\nInitialize a new `ConstraintTreeNode` with the same `solution` and\n`constraints` as the parent node\n\n\n\n\n\n","category":"method"},{"location":"reference/#CRCBS.initialize_root_node","page":"API Reference","title":"CRCBS.initialize_root_node","text":"`initialize_root_node`\n\nConstruct an empty `ConstraintTreeNode` from a `AbstractMAPF` instance\n\n\n\n\n\n","category":"function"},{"location":"reference/#CRCBS.is_available-Tuple{ReservationTable,Any,Any,Any,Any}","page":"API Reference","title":"CRCBS.is_available","text":"is_available\n\nReturns false if the proposed reservation is not available to any of the agent_ids\n\n\n\n\n\n","category":"method"},{"location":"reference/#CRCBS.is_consistent-Union{Tuple{P}, Tuple{G}, Tuple{S}, Tuple{P,S,G}} where P<:Path where G where S","page":"API Reference","title":"CRCBS.is_consistent","text":"is_consistent(solution,mapf)\n\nCheck if solution satisfies start and end constraints\n\n\n\n\n\n","category":"method"},{"location":"reference/#CRCBS.is_valid-Tuple{C} where C<:Conflict","page":"API Reference","title":"CRCBS.is_valid","text":"Checks if a conflict is valid \n\n\n\n\n\n","category":"method"},{"location":"reference/#CRCBS.low_level_search!-Union{Tuple{N}, Tuple{M}, Tuple{Any,M,N}, Tuple{Any,M,N,Any}} where N<:ConstraintTreeNode where M<:AbstractMAPF","page":"API Reference","title":"CRCBS.low_level_search!","text":"`low_level_search!(\n    solver,\n    mapf::AbstractMAPF,\n    node::ConstraintTreeNode,\n    idxs=collect(1:num_agents(mapf)),\n    path_finder=a_star!)`\n\nReturns a low level solution for a MAPF with constraints. The heuristic\nfunction for cost-to-go is user-defined and environment-specific\n\n\n\n\n\n","category":"method"},{"location":"reference/#CRCBS.num_actions","page":"API Reference","title":"CRCBS.num_actions","text":"num_actions(env)\n\nReturns the cardinality of the single agent state space for an environment.     If the state and action spaces are finite and discrete, a discrete     constraint table may be used for fast lookup.\n\n\n\n\n\n","category":"function"},{"location":"reference/#CRCBS.num_states","page":"API Reference","title":"CRCBS.num_states","text":"num_states(env)\n\nReturns the cardinality of the single agent state space for an environment.     If the state and action spaces are finite and discrete, a discrete     constraint table may be used for fast lookup.\n\n\n\n\n\n","category":"function"},{"location":"reference/#CRCBS.partially_set_path!-Union{Tuple{T}, Tuple{M}, Tuple{V}, Tuple{T,Int64,Array{Int64,1}}, Tuple{T,Int64,Array{Int64,1},Int64}} where T<:HardConflictTable{V,M} where M where V","page":"API Reference","title":"CRCBS.partially_set_path!","text":"partially_set_path!\n\nOnly replaces the cached path from start_time to length(path). Useful if you want the remainder of the cached path to stay in the lookup table (i.e. for repairing an existing plan).\n\n\n\n\n\n","category":"method"},{"location":"reference/#CRCBS.pibt_priority_law-NTuple{4,Any}","page":"API Reference","title":"CRCBS.pibt_priority_law","text":"pibt_priority_law(solver,mapf,cache,i)\n\nReturns a value that will determine the priority of agent i relative to other agents. A lower value means higher priority.\n\n\n\n\n\n","category":"method"},{"location":"reference/#CRCBS.pibt_step!","page":"API Reference","title":"CRCBS.pibt_step!","text":"pibt_step!(solver,mapf,i,j=-1)\n\ni is the id of the higher priority agent, j is the index of the lower priority agent.\n\n\n\n\n\n","category":"function"},{"location":"reference/#CRCBS.populate_soft_lookup_table!","page":"API Reference","title":"CRCBS.populate_soft_lookup_table!","text":"populate_soft_lookup_table!(CAT,start_times,start_vtxs,goal_vtxs)\n\n\n\n\n\n","category":"function"},{"location":"reference/#CRCBS.profile_solver!-Tuple{Any,Any}","page":"API Reference","title":"CRCBS.profile_solver!","text":"profile_solver!(solver,mapf)\n\nProfile solver on mapf: Returns\n\nsolution, timer_results\n\n\n\n\n\n","category":"method"},{"location":"reference/#CRCBS.recompute_cost","page":"API Reference","title":"CRCBS.recompute_cost","text":"recompute_cost\n\nRecompute the cost of path (according to env), beginning from initial cost c0.\n\n\n\n\n\n","category":"function"},{"location":"reference/#CRCBS.reconstruct_path!-NTuple{4,Any}","page":"API Reference","title":"CRCBS.reconstruct_path!","text":"reconstruct path by working backward from the terminal state\n\n\n\n\n\n","category":"method"},{"location":"reference/#CRCBS.remove_constraint!","page":"API Reference","title":"CRCBS.remove_constraint!","text":"Removes a CBSConstraint to a DiscreteConstraintTable \n\n\n\n\n\n","category":"function"},{"location":"reference/#CRCBS.reserve!-Union{Tuple{R}, Tuple{Array{R,1},R}} where R<:ResourceReservation","page":"API Reference","title":"CRCBS.reserve!","text":"reserve!(table,reservation)\n\nAttempts to add a reservation to the table. If the reservation conflicts with an existing reservation, does nothing and returns false. If successful, returns true.\n\n\n\n\n\n","category":"method"},{"location":"reference/#CRCBS.reserved_by-Union{Tuple{R}, Tuple{Array{R,1},R}} where R<:ResourceReservation","page":"API Reference","title":"CRCBS.reserved_by","text":"reserved_by\n\nReturns the IDs of agents who have reserved a resource within a specific time window.\n\n\n\n\n\n","category":"method"},{"location":"reference/#CRCBS.reset_solver!-Tuple{SolverLogger}","page":"API Reference","title":"CRCBS.reset_solver!","text":"reset_solver!(solver)\n\nResets iteration counts and start times.\n\n\n\n\n\n","category":"method"},{"location":"reference/#CRCBS.reset_undecided!-Tuple{PIBTCache}","page":"API Reference","title":"CRCBS.reset_undecided!","text":"Fills `undecided` with all active agents (inactive agents have already\nselected their actions)\n\n\n\n\n\n","category":"method"},{"location":"reference/#CRCBS.run_profiling-Tuple{Any,Any}","page":"API Reference","title":"CRCBS.run_profiling","text":"run_profiling(config,loader)\n\nProfile the performance of one or more solvers on a set of problems defined by files in a directory. Args:\n\nconfig: A named tuple or struct with at least the following fields:\nproblem_dir::String : path to problem files.\nsolver_configs : A vector of objects, each of which has the fields:\nsolver : a solver complying with the CRCBS interface.\nresults_path::String : path at which to store results.\nfeats : A vector of Feature objects, which defines the specific\nfeatures to be extracted and saved.\nLoader: Any kind of cache on which load_problem(loader,problem_file)   can be called.\n\n\n\n\n\n","category":"method"},{"location":"reference/#CRCBS.search_constraints-Union{Tuple{N}, Tuple{Any,DiscreteConstraintTable,N}} where N<:PathNode","page":"API Reference","title":"CRCBS.search_constraints","text":"search_constraints(env,table,n::PathNode)\n\nReturns all `CBSConstraint`s and `CBSConstraint`s that match `n`,\nregardless of time.\n\n\n\n\n\n","category":"method"},{"location":"reference/#CRCBS.serialize","page":"API Reference","title":"CRCBS.serialize","text":"serialize(env,state,t=-1)\n\nEncodes a state or action as an integer\n\n\n\n\n\n","category":"function"},{"location":"reference/#CRCBS.set_constraint!","page":"API Reference","title":"CRCBS.set_constraint!","text":"Sets a `CBSConstraint` value in a DiscreteConstraintTable\n\n\n\n\n\n","category":"function"},{"location":"reference/#CRCBS.solve!-Tuple{Any,Vararg{Any,N} where N}","page":"API Reference","title":"CRCBS.solve!","text":"`solve!(solver, args ...)`\n\nRun the algorithm represented by `solver` on an instance of a Multi-Agent\nPath-Finding problem.\n\n\n\n\n\n","category":"method"},{"location":"reference/#CRCBS.sorted_actions-Tuple{Any,Any}","page":"API Reference","title":"CRCBS.sorted_actions","text":"sorted_actions(env,s)\n\nReturn a vector of actions sorted lowest cost to highest cost.\n\n\n\n\n\n","category":"method"},{"location":"reference/#CRCBS.state_space_trait-Tuple{Any}","page":"API Reference","title":"CRCBS.state_space_trait","text":"state_space_trait(env)\n\nDefaults to DiscreteSpace\n\n\n\n\n\n","category":"method"},{"location":"reference/#CRCBS.time_to_deadline-Tuple{Any}","page":"API Reference","title":"CRCBS.time_to_deadline","text":"time_to_deadline(solver)\n\ntime to deadline(solver) or runtime_limit(solver)â€“whichever is shorter.\n\n\n\n\n\n","category":"method"},{"location":"reference/#CRCBS.trim_path!-Tuple{Any,Any,Any}","page":"API Reference","title":"CRCBS.trim_path!","text":"trim_path!(env,path,T)\n\nModify path to terminate at time step T. If length(path) < T, the path will be extended to time step T.\n\n\n\n\n\n","category":"method"},{"location":"reference/#CRCBS.trim_solution!-Tuple{Any,Any,Any}","page":"API Reference","title":"CRCBS.trim_solution!","text":"trim_solution!\n\nModify solution so that all paths terminate at time step T.\n\n\n\n\n\n","category":"method"},{"location":"reference/#CRCBS.update_fat_path_conflict_table!-Union{Tuple{E}, Tuple{M}, Tuple{M,AbstractArray{T,2} where T,E,Any}} where E where M<:FatPathCostModel","page":"API Reference","title":"CRCBS.update_fat_path_conflict_table!","text":"update_conflict_table!(table,nodes)\n\nUpdates a conflict table with a set of nodes.\n\n\n\n\n\n","category":"method"},{"location":"reference/#CRCBS.wait","page":"API Reference","title":"CRCBS.wait","text":"`wait(s)`\n\nreturns an action that corresponds to waiting at state s\n\n\n\n\n\n","category":"function"},{"location":"reference/#CRCBS.write_results-NTuple{5,Any}","page":"API Reference","title":"CRCBS.write_results","text":"write_results(loader,solver_config,prob,problem_file,results)\n\nWrite results results of profiling solver_config.solver on problem prob of name problem_name. Can be overloaded to dispatch on problem type when applicable.\n\n\n\n\n\n","category":"method"},{"location":"reference/#GraphUtils.get_graph-Tuple{GraphEnv}","page":"API Reference","title":"GraphUtils.get_graph","text":"GraphUtils.get_graph(env::GraphEnv)\n\nMust be implemented for all concrete subtypes of GraphEnv\n\n\n\n\n\n","category":"method"},{"location":"reference/#CRCBS.BenchmarkInterface.MovingAIBenchmarkFile","page":"API Reference","title":"CRCBS.BenchmarkInterface.MovingAIBenchmarkFile","text":"MovingAIBenchmarkFile\n\nPoints to a TOML-formatted file that contains the following elements:     scenario = \"/path/to/scenario/file.scen\"     mapfile = \"/path/to/map/file.map\"     bucketidx = 1 # an integer     n_agents = 2 # an integer\n\nExtension is .bm\n\n\n\n\n\n","category":"type"},{"location":"reference/#CRCBS.BenchmarkInterface.ProblemLoader","page":"API Reference","title":"CRCBS.BenchmarkInterface.ProblemLoader","text":"ProblemLoader\n\nCan be queried via get_problem(iterator,problem_filename) to return MAPF instances.\n\n\n\n\n\n","category":"type"},{"location":"reference/#CRCBS.BenchmarkInterface.is_same_scenario_and_bucket-Tuple{Any,Any}","page":"API Reference","title":"CRCBS.BenchmarkInterface.is_same_scenario_and_bucket","text":"is_same_scenario_and_bucket(config1,config2)\n\nChecks that two problem_configs are on the same scenario and bucket.\n\n\n\n\n\n","category":"method"},{"location":"reference/#CRCBS.BenchmarkInterface.parse_map_file","page":"API Reference","title":"CRCBS.BenchmarkInterface.parse_map_file","text":"parse_map_file\n\nParses a .map file (see citation below) into an indicator grid. Each cell of the map is encoded by one of the following characters:     . - passable terrain     G - passable terrain     @ - out of bounds     O - out of bounds     T - trees (unpassable)     S - swamp (passable from regular terrain)     W - water (traversable, but not passable from terrain)\n\nReturns an array of integers encoded as IMPASSABLE=>1, FREE=>0 (we treat only 'G', 'S', and '.' as free).\n\n@article{sturtevant2012benchmarks,   title={Benchmarks for Grid-Based Pathfinding},   author={Sturtevant, N.},   journal={Transactions on Computational Intelligence and AI in Games},   volume={4},   number={2},   pages={144 â€“ 148},   year={2012},   url = {http://web.cs.du.edu/~sturtevant/papers/benchmarks.pdf}, }\n\n\n\n\n\n","category":"function"},{"location":"reference/#CRCBS.BenchmarkInterface.parse_mapf_scenario","page":"API Reference","title":"CRCBS.BenchmarkInterface.parse_mapf_scenario","text":"parse_mapf_scenario(filename,map_path=\"\")\n\nParses a .scen file into a set of 'buckets', where each bucket contains a list of (start location,goal location) pairs. Each bucket can be used to instantiate MAPF instances some (or all) of these pairs. The benchmarking approach proposed on the benchmark website (https://www.movingai.com/benchmarks/index.html) is to start with a 2-agent MAPF for each bucket, and increase the number of agents until solver time out.\n\n\n\n\n\n","category":"function"},{"location":"reference/#CRCBS.BenchmarkInterface.profile_with_skipping!-Tuple{Any,Any}","page":"API Reference","title":"CRCBS.BenchmarkInterface.profile_with_skipping!","text":"profile_with_skipping!(config,loader)\n\nFollow the Moving AI benchmarking paradigm, where problems are skipped if the solver has already failed on the same problem instance with fewer agents.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = CRCBS","category":"page"},{"location":"#CRCBS","page":"Home","title":"CRCBS","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package is for modeling and solving multi agent path planning problems.","category":"page"},{"location":"#Where-to-begin?","page":"Home","title":"Where to begin?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"getting_started.md\"]\nDepth = 2","category":"page"},{"location":"#Profiling-Solver-Performance","page":"Home","title":"Profiling Solver Performance","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"profiling.md\"]\nDepth = 2","category":"page"},{"location":"#Core-Types","page":"Home","title":"Core Types","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"library.md\"]\nDepth = 2","category":"page"},{"location":"#API-Reference","page":"Home","title":"API Reference","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"reference.md\"]\nDepth = 2","category":"page"},{"location":"profiling/#Profiling","page":"Profiling","title":"Profiling","text":"","category":"section"},{"location":"profiling/","page":"Profiling","title":"Profiling","text":"To run the suite of experiments described in the ICRA paper,  run the script below (if you wish to use Gurobi,  you'll need to obtain a license and install Gurobi.jl.","category":"page"},{"location":"profiling/","page":"Profiling","title":"Profiling","text":"# copied from CRCBS/scripts/icra_experiments.jl\nusing CRCBS \n# NOTE that the experiments described in \"Optimal Sequential Task Assignment and \n# Path Finding for Multi-Agent Robotic Assembly Planning\", Brown et al. \n# were performed using Gurobi as the black box MILP solver. To use the default\n# (GLPK), simply comment out the following two lines.\nusing Gurobi\nset_default_milp_optimizer!(Gurobi.Optimizer)\n\n## ICRA experiments\n# You may want to redefine base_dir\n# -------------------------- #\nbase_dir            = joinpath(\"/scratch/task_graphs_experiments\")\n# -------------------------- #\nproblem_dir         = joinpath(base_dir,\"pctapf_problem_instances\")\nbase_results_path   = joinpath(base_dir,\"pctapf_results\")\n\nfeats = [\n    RunTime(),\n    FeasibleFlag(),\n    OptimalFlag(),\n    OptimalityGap(),\n    SolutionCost(),\n    PrimaryCost(),\n    SolutionAdjacencyMatrix(),\n]\nsolver_configs = [\n    (\n        solver = NBSSolver(\n            assignment_model = CRCBSMILPSolver(AssignmentMILP()),\n            path_planner = CBSSolver(ISPS()),\n            ),\n        results_path = joinpath(base_results_path,\"AssignmentMILP\"),\n        feats = feats,\n        objective = MakeSpan(),\n    ),\n]\n\nbase_config = Dict(\n    :env_id => \"env_2\",\n    :num_trials => 16,\n    :max_parents => 3,\n    :depth_bias => 0.4,\n    :dt_min => 0,\n    :dt_max => 0,\n    :dt_collect => 0,\n    :dt_deliver => 0,\n)\nsize_configs = [Dict(:M => m, :N => n) for (n,m) in Base.Iterators.product(\n    [10,20,30,40],[10,20,30,40,50,60]\n)][:]\nproblem_configs = map(d->merge(d,base_config), size_configs)\n\n# loader = PCTA_Loader() # to test task assignment only\nloader = PCTAPF_Loader()\nadd_env!(loader,\"env_2\",init_env_2())\nwrite_problems!(loader,problem_configs,problem_dir)\nfor solver_config in solver_configs\n    set_runtime_limit!(solver_config.solver,100)\n    warmup(loader,solver_config,problem_dir)\n    run_profiling(loader,solver_config,problem_dir)\nend","category":"page"}]
}
